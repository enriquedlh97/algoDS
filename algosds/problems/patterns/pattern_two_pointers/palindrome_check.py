"""
Problem:

Write a function that takes in a non-empty string and returns
a boolean representing whether the string is a palindrome.

Single-character strings are palindromes.


Input:
    string: "abcdcba"

Output:
    True
"""

import math


# Time O(n), where n is the size of the string
# Space O(1)
def is_palindrome_two_pointers_implicit(string):
    """ Uses front and back pointers implicitly to compare characters

    Iterates over half of the string and each time it compares the front character with a corresponding back character.
    It does not explicitly define the pointers, it uses the idx generated by the for loop.

    :param string: String to check if it is palindrome
    :return: True if it is palindrome, False otherwise
    """
    for idx in range(0, math.floor(len(string) / 2)):
        if string[idx] != string[-(idx + 1)]:
            return False
    return True


# Time O(n), where n is the size of the string
# Space O(1)
def is_palindrome_two_pointers_implicit_pythonic(string):
    """ Uses front and back pointers implicitly to compare characters using python notation

    Iterates over the complete string and each time it compares the front character with a corresponding back character.
    It does not explicitly define the pointers, it uses the idx generated by the for loop.

    It is less efficient than the other two pointer solutions (explicit and implicit pointers) because this solution
    iterates over the complete string and the other two solutions iterate over half the string. Nevertheless, the time
    complexity stays O(n) for all solutions. This solution is a lot simpler, more pythonic and has the same time
    complexity.

    :param string: String to check if it is palindrome
    :return: True if it is palindrome, False otherwise
    """
    return string == string[::-1]


# Time O(n^2), where n is the size of the string
# Space O(n), because a string of size n is created
def is_palindrome_reversed_string_for_loop(string):
    """ Compares string to new reversed string generated by for loop

    The input string is reversed using a for loop ( implies a O(n^2) operation). This reversed string is then compared
    to the input string to see whether it is palindrome.

    Why is it O(n^2) time complexity?
    Because at each iteration in the for loop, the first solution adds a character to the reversed string. In most
    languages where strings are immutable, adding a character to a string involves re-creating the entire string, which
    in turn involves iterating through every character in the string (an O(n)-time operation).

    This means that an O(n)-time operation has to be performed at each iteration in the for loop, leading to an
    O(n^2)-time algorithm overall.

    :param string: String to check if it is palindrome
    :return: True if it is palindrome, False otherwise
    """
    reversed_string = ""

    for character_idx in reversed(range(len(string))):
        reversed_string += string[character_idx]

    return string == reversed_string


# Time O(n), where n is the size of the string
# Space O(n), because a string of size n is created
def is_palindrome_reversed_string_join(string):
    """ Compares string to new reversed string generated by .join() concatenation

    To avoid the O(n)-time operation needed each time a character is added to the reversed string, the reversed string
    is defined as an empty array, and each character is appended to the array, O(1)-time operation, by iterating over
    the input string in a backwards manner.

    Since appending to an array is only O(1)-time, instead of the O(n)-time needed to add a character to a string, there
    is a significant time reduction.

    We still iterate over the input string, but this time make an O(1)-time operation for each character.

    Once the reversed string array is created, the .join() method is used to concatenate the array and make it a valid
    string. This process takes O(n)-time, nevertheless, it is only performed once. Making the final time complexity
    O(2n) -> O(n).

    :param string: String to check if it is palindrome
    :return: True if it is palindrome, False otherwise
    """
    reversed_string = []
    for character_idx in reversed(range(len(string))):
        reversed_string.append(string[character_idx])

    return string == "".join(reversed_string)


# Recursion
# Time O(n), where n is the size of the string
# Space O(n), because of the call stack
def is_palindrome_recursion(string, front_idx=0):
    """ Compares front and back characters recursively

    The base case is when the pointers are at the middle. For strings with odd number of characters occurs when
    front_idx is the same as back_idx. For strings with even number of characters this occurs when front_idx is bigger
    than back_idx. This base case returns True.

    In the recursive case, the only condition to continue is to check whether the current pair of characters are the
    same. If they are not the same, the recursion ends and "False" is returned.

    :param string: String to check if it is palindrome
    :param front_idx: Indicates the index at which the current string is assumed to start. Helps for traversing.
    :return: True if it is palindrome, False otherwise
    """
    back_idx = len(string) - 1 - front_idx
    if front_idx >= back_idx:
        return True
    else:
        return string[front_idx] == string[back_idx] and is_palindrome_recursion(string, front_idx + 1)


# Tail recursion
def is_palindrome_tail_recursion(string, front_idx=0):
    """ Compares front and back characters recursively using tail recursion

    Tail recursion explanation: https://www.youtube.com/watch?v=_JtPhF8MshA and
    https://chrispenner.ca/posts/python-tail-recursion


    Tail recursion is mostly optimized by the compiler. So it is not a guaranteed for all tail recursive functions that
    the space complexity will be reduced. They idea is to not have to wait until the base case to compute the final \
    return value. For the previous recursive function the final return statement has to wait until the recursive calls
    reach the base case to return True when a string is in deed a palindrome.

    For this function, in theory, there is no need to keep a call stack since the recursive call of the function does
    not require to wait for deeper function calls. It basically starts a new function call with no need for keeping
    in memory the previous function calls.

    :param string: String to check if it is palindrome
    :param front_idx: Indicates the index at which the current string is assumed to start. Helps for traversing.
    :return: True if it is palindrome, False otherwise
    """
    back_idx = len(string) - 1 - front_idx
    if front_idx >= back_idx:
        return True
    elif string[front_idx] != string[back_idx]:
        return False
    else:
        return is_palindrome_tail_recursion(string, front_idx + 1)


# Two pointers
# Time O(n), where n is the size of the string
# Space O(1),
def is_palindrome_two_pointers_explicit(string):
    """ Uses front and back pointers, explicitly defined, to compare characters

    Iterates over half of the string and each time it compares the front character with a corresponding back character.
    It explicitly defines the front and back pointers.

    :param string: String to check if it is palindrome
    :return: True if it is palindrome, False otherwise
    """
    front_pointer = 0
    back_pointer = len(string) - 1
    while front_pointer < back_pointer:
        if string[front_pointer] != string[back_pointer]:
            return False
    front_pointer += 1
    back_pointer -= 1
    return True
